layout: “title”
title: Swift 学习点滴 二
date: 2015-02-16 13:30:47
tags: Swift
---
前言: 作为学习Swift的一个记录, 记录点滴成长.
<!--more-->

# Swift 条件选择(if Switch),循环结构
## switch ##

```objectivec
var i = 0
switch i {
case 0:
print("0")
case 1:
print("1")
default:
print("default")
}
```
## 不用加上break, Swift的Switch语句会自动在case结尾处加上break, 但是在某些情况下，我们可能会希望Switch能同时执行两条case如下: ##

```objectivec
var j = 3
switch j {
case 0,3: // 在case后的多个条件中，用逗号隔开即可
print("0, 3")
fallthrough //使用新的关键字fallthrough能使Switch在执行完一个case之后，紧接着执行下一条case。
case 1:
print("1")
default:
print("default")
}
// 结果
// 0, 3
// 1
// 当你不想在default中执行任何操作的时候, 可以在default中手动加上break
```
## 支持多种数据类型:浮点, 布尔, 字符串,支持区间运算符例子如下 ##

```objectivec
var k = 15
switch i {
case 0 ... 10:
break
case 11 ... 20:
break
default:
break
}
```
## 支持元组 ##

```objectivec
let request = (true,"success")
switch request {
case (true, "success"):
print("success")
break
//
case (false, "failed"):
print("failed")
break
//
default: break
//
}

```
## 支持额外的逻辑判断 ##

```objectivec
let request1 = (0,"success")
switch request1 {
case (0, let state) where state != "success":
state
case (let errorCode, _):
"error code is \(errorCode)"//被输出:"error code is 0"
}

var string:String = "Hello"
if string == "Hello"{
print("YES")
}else{
print("NO")
}
```
## 循环for ##

```objectivec
// for in
for var i in 1...5{
print(i)
}
```

```objectivec
// while
var ii = 0
while ii < 11
{
//  执行10次
print("while")
}
```

```objectivec
// repeat-while::do-while
var jj = 0
repeat{
//
}while i < 11
```

# Swift 函数的基本写法与使用元组实现返回多个值

## 无参数无返回值 ##

```objectivec
let studentScores = [12, 55, 65, 38, 99, 88, 0]
```

```objectivec
func studySwift() ->Void
{
print("无参无返回值")
}
```
## 无参数有返回值 ##

```objectivec
func studySwift1() ->String
{
let name:String = "无参数有返回值"
return name
}
```
## 有参数无返回值 ##

```objectivec
func sayHi (name:String) ->Void
{
print("Hi, \(name)")
}
```
## 有参数有返回值 ##

```objectivec
func sayHello (name:String)->String
{
let result = "Hello," + name
return result
}
```
## 使用元组返回多个值 ##

```objectivec
func maxminScores ( scores:[Int] ) -> (maxscore:Int, minscore:Int)
{
var curmax = scores[0], curmin = scores[0]
for score in scores[1..<scores.count]
{
curmax = max(curmax, score)
curmin = min(curmin, score)
}
return (curmax, curmin)
}
```
## 调用 ##

```objectivec
override func viewDidLoad() {
super.viewDidLoad()
// Do any additional setup after loading the view, typically from a nib.

// "!"表示这个可选变量存在，可以使用，如果用"!"访问不存在的可选变量会导致一些错误

// "?"表示这个变量可能不存在，如果不存在，"?"所在语句后面的内容都不会执行

// !是一个强制拆包,告诉编译器我绝对肯定代码能够执行, 如: strValue!.hashValue ,如果不能执行则报错。
// ?是表示一个不确定,strValue?.hashValue 就等于OC的if(strValue){  [strValue hashValue]; } 有就执行,有没后面代码就不执行。 不会报错。
关于 ? ! 的解释转自:        [http://blog.csdn.net/wmqi10/article/details/37562071](http://blog.csdn.net/wmqi10/article/details/37562071)


let name:String = "zjw"
print(sayHello(name))
sayHi(name)
studySwift()
print(studySwift1())
let result = maxminScores(studentScores)
print("max:\(result.maxscore), min:\(result.minscore)")
}

```
# Swift 实例方法&类型方法

```objectivec
override func viewDidLoad() {
super.viewDidLoad()
// Do any additional setup after loading the view, typically from a nib.

let counter = Counter()
counter.reset()
print(counter.count) // 0
counter.incrementBy(5)
print(counter.count) // 5
counter.increment()
print(counter.count) //

let counter1 = Counter1()
counter1.incrementBy(5, numberOfTimes: 10)
print(counter1.count) // 50

let point = Point()
print(point.isToRightOfX(1)) // 
print(point.x)
}

```

```objectivec
// 'Counter'类定义了三个個实例方法
class Counter {
var count = 0
func incrementBy(amount: Int){
count += amount // count + amount
}
func reset(){
count = 0 // 重置 count = 0
}
func increment(){
self.count++
}
}
```

```objectivec
// 稍微复杂一点的
class Counter1 {
var count: Int = 0
func incrementBy(amount: Int, numberOfTimes: Int){
count += amount * numberOfTimes
}
}
```

```objectivec
// 下面的例子中，`self`消除方法参数`x`和实例属性`x`之间的歧义
struct Point {
var x = 0.0, y = 0.0
func isToRightOfX(x:  Double) -> Bool{
print(x)           // 1.0
return self.x >= x // self.x = 0 x = 上边赋值1
}
}
```
/// 第一：struct没有继承的功能，而class是可以继承的，这是面向对象语言的核心能力，class当然会有这个能力。

/// 第二: 体现在内存使用上，struct是通过值传递，而class是通过引用传递的，举个简单的例子window对象一定会选择设计成class的实例，而不应该是struct的，通常我们一定不想在设备中拷贝出多个window对象来，对么？   
解释来自:
[http://blog.objcc.com/swift-struct-class/](http://blog.objcc.com/swift-struct-class/)



<div align=center>
微信公众号 得到最快最新的推送
</div>

<div align=center>
![](http://ww1.sinaimg.cn/large/0060lm7Tgw1f9656jhucpj307607674r.jpg)
</div>
