layout: “title”
title: Swift 学习点滴 三
date: 2015-02-22 13:42:13
tags: Swift
---

前言: 作为学习Swift的一个记录, 记录点滴成长.
<!--more-->
### Swift 类型转换is, as, Any, AnyObject(十二)

/// 父类 `Person`
```
class Person {
var name: String
init(name: String){
self.name = name
}
}
```
/// 子类 `Woman`
```
class Woman: Person {
var female: String
init(name: String, male: String) {
self.female = male
super.init(name: name)
}
}
```
/// 子类 `Man`
```
class Man: Person {
var weight: String
init(name: String, weight: String) {
self.weight = weight
super.init(name: name)
}
}
```
```
let arrays = [
Woman(name: "gzz", male: "she"),
Woman(name: "glz", male: "she"),
Man(name: "ty", weight: "180"),
Man(name: "az", weight: "101"),
Man(name: "az", weight: "102")
]  /// arrays 的类型被推断为Person
```
#####检查类型（Checking Type）
用类型检查操作符（`is`）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 `true`，否则返回 `false`。
下面的例子定义了两个变量，`womanCount` 和 `manCount`，用来计算数组 `arrays` 中 `Woman` 和 `Man` 类型的实例数量:
```
var womanCount = 0
var manCount = 0

for item in arrays{
if item is Woman{
++womanCount
}
if item is Man{
++manCount
}
}
print("womamCount: \(womanCount)") // 2
print("manCount: \(manCount)")     // 3
```
数组中的每一个 `item` 可能是 `Woman` 或 `Man`。事前你不知道每个 `item` 的真实类型，所以使用类型转换（`as?`）去检查  
```
for item in arrays{
if let _ = item as? Woman{
print("woman")
//
}
if let _ = item as? Man{
print("man")
//
}
}
```
#####Any 和 AnyObject 的类型转换
`Swift` 为不确定类型提供了两种特殊的类型别名：
`AnyObject` 可以表示任何类类型的实例。
`Any` 可以表示任何类型，包括函数类型。
`AnyObject`
下面的示例定义了一个 [AnyObject] 类型的数组并填入三个 `Man` 类型的实例：
```
let objects: [AnyObject] = [
Man(name: "Xt", weight: "180"),
Man(name: "Xt1", weight: "180"),
Man(name: "Xt2", weight: "180"),
]
```
因为知道这个数组只包含 `Man` 实例，你可以直接用（`as!`）下转并解包到非可选的 `Man` 类型
```
for object in objects{
let man = object as! Man
print("man :'\(man.name)'")
}
```
`Any`
使用 `Any` 类型来和混合的不同类型一起工作，包括函数类型和非类类型。它创建了一个可以存储
```
var things = [Any]()
// 添加
things.append(0)
things.append(3.14159)
things.append("hello")
things.append((3.0, 5.0))
things.append(Man(name: "Xt", weight: "171"))
things.append(Woman(name: "Xt1", male: "ll"))
```
你可以在 `switch` 表达式的 `case` 中使用 `is` 和 `as` 操作符来找出只知道是 `Any` 或 `AnyObject` 类型的常量或变量的具体类型。下面的示例迭代 `things` 数组中的每一项，并用 `switch` 语句查找每一项的类型。有几个 `switch` 语句的 `case` 绑定它们匹配到的值到一个指定类型的常量，从而可以打印这些值
```
for thing in things {
switch thing {
case 0 as Int:
print("zero as an Int")
case let someDouble as Double where someDouble > 0:
print("a positive double value of \(someDouble)")
case let someString as String:
print("a string value of \"\(someString)\"")
case let (x, y) as (Double, Double):
print("an (x, y) point at \(x), \(y)")
case let man as Man:
print("Man: \(man.name)")
case let woman as Woman:
print("woman: \(woman.name)")
default:
print("something else")
}
}
```
### 非泛型函数
```
/// 交换两个整形的值
func swapTwoNumbersInt(inout a: Int, inout _ b:Int)
{
let temp = a
a = b
b = temp
}
```
```
/// 交换两个字符串的值
func swapTwoString(inout string1: String, inout _ string2: String)
{
let temp = string1
string1 = string2
string2 = temp
}
```
如果想实现不确定类型值的交换上面的方法是不是显得太过死板,所以泛型的出现很好的解决这个
####泛型
泛型函数--泛型函数可以适用于任何类型
1. 这个函数的泛型版本使用了占位类型名（在这里用字母 T 来表示）来代替实际类型名（例如 `Int`、`String`, 占位类型名没有指明 T 必须是什么类型，但是它指明了 `a` 和 `b` 必须是同一类型 T，无论 T 代表什么类型
2. 这个泛型函数名（swapTwoValues(_:_:)）后面跟着占位类型名（T），并用尖括号括起来（<T>）。这个尖括号告诉 `Swift` 那个 T 是 swapTwoValues(_:_:) 函数定义内的一个占位类型名，因此 `Swift` 不会去查找名为 T 的实际类型
```
/// 实现不确定类型值交换
func swapTwoValues<T>(inout a: T, inout _ b: T)
{
let temp = a
a = b
b = temp
}
```
### 类型约束
1. `Swift` 的`Dictionary` 类型对字典的键的类型做了些限制。在字典的描述中，字典的键的类型必须是可哈希（`hashable`）的。也就是说，必须有一种方法能够唯一地表示它。`Dictionary` 的键之所以要是可哈希的，是为了便于检查字典是否已经包含某个特定键的值。若没有这个要求，`Dictionary` 将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。
2. 为了实现这个要求，一个类型约束被强制加到 `Dictionary` 的键类型上，要求其键类型必须符合 `Hashable` 协议，这是 `Swift` 标准库中定义的一个特定协议。所有的 `Swift` 基本类型（例如 `String`、`Int`、`Double` 和 `Bool`）默认都是可哈希的。
3. 当你创建自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的，描述的是类型在概念上的特征，而不是它们的显式类型
#####for example 类型约束
```
/// 非泛型
func findStringIndex(array: [String], _ valueToFind: String) -> Int? {
for (index, value) in array.enumerate() {
if value == valueToFind {
return index
}
}
return nil
}
```
```
/// 泛型
/// T 遵循 Equatable
func findIndex<T: Equatable>(array: [T], _ valueToFind: T) -> Int? {
for (index, value) in array.enumerate() {
/// 不是所有的 Swift 类型都可以用等式符（==）进行比较
/// Swift 标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符（==）及不等符(!=)，从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 Equatable 协议。
if value == valueToFind {
return index
}
}
return nil
}
```
####下面是我在viewDidLoad中的调用
```
var a = 10
var b = 20
//        self.swapTwoNumbersInt(&a, &b)
print("b: \(b)")

var string1 = "Big"
var string2 = "Small"
//        self.swapTwoString(&string1, &string2)
print("string2: \(string2)")
///
self.swapTwoValues(&a, &b)
print("b: \(b)")
///
self.swapTwoValues(&string1, &string2)
print("string2: \(string2)")
///
let strings = ["button", "label", "view", "model", "Controller"]
if let foundIndex = findStringIndex(strings, "label") {
print("\(foundIndex)")
}
///
if let foundIndex = findIndex(strings, "view") {
print("view: \(foundIndex)")
}
///
let ints = [1,2,3,4,55,6]
if let foundIndex = findIndex(ints, 55) {
print("55: \(foundIndex)")
}
```
类型格式转化
```
1. labelTitle.text = NSString(format: "%d", indexPath.row) as String
String <-> int
2. a = Int(scrollView.contentOffset.x)
int   <->  cgfloat
3. dic["title"] as? String
NSString <-> String
```

总结: 使用泛型写出的代码是不是功能很强大? 学起来吧.

<div align=center>
微信公众号 得到最快最新的推送
</div>

<div align=center>
![](http://ww1.sinaimg.cn/large/0060lm7Tgw1f9656jhucpj307607674r.jpg)
</div>
