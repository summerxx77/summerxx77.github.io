layout: “title”
title: iOS 谈谈RunLoop我的一些理解
date: 2015-09-17 10:15:15
tags: RunLoop
---

做iOS开发有一点时间了, 或者更确切的说已经好长一段时间了, 对于iOS开发或者说Objective-C 语言的理解十分有限, 很多停留在系统API的调用上, 这让我感到很焦虑, 或者说很悲哀, 这样下去并不能达到真正的成长, 今天试着谈一谈深层次一些的东西, 谈谈RunLoop 下面进入今天的主题.

<!--more-->
#### RunLoop的一些理解

RunLoop是在iOS开发中很常见的一个概念, 似乎离我们很近, 却又很遥远.

一般来说一个线程只执行一个任务, 执行结束退出, 而在我们开发App的时候, 似乎需要一种新概念来保证App永远处于"待命"的状态, Node.js的实践处理, Windows程序的消息循环, 而在iOS开发中叫做RunLoop, 更加准确描述他的含义我觉得可以这样:

- 在没有事件(点击, 双击等等)需要处理的时候, 他是以一种休眠的状态存在, 以保证不占用系统的资源, 在有事件需要处理的时候立即被唤醒.

- 所以RunLoop实际就是一个管理消息和事件处理的对象.

- 他似乎类似进入了一个圈, 就像电影死亡游轮里的剧情一样: 

<div align=center>
-- 杀人 -- 下船 -- 上船 -- 杀人; 如此反复
</div>
<div align=center>
-- 休眠等待 --触发-- 处理事件 --完成-- 休眠等待; 如此反复
</div>

- 在iOS开发中, 提供了两个这样的对象: NSRunLoop 和 CFRunLoopRef.
CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。
NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。

#### RunLoop与线程
每个线程，包括程序的主线程（main thread）都有与之相应的RunLoop对象, 也就是说是一一对应的关系.
- 主线程的RunLoop是默认启动的
iOS的应用程序里面, 在main.m 会有这样一个面main()函数

```objectivec
int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
```
#### PerformSelecter

当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效.

#### RunLoop实际应用举例

1. AFN 2. AsyncDisplayKit
后记: 水平有限, 请多指教.
[https://github.com/facebook/AsyncDisplayKit/](https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m)

文章参照:

[http://blog.ibireme.com/2015/05/18/runloop/](http://blog.ibireme.com/2015/05/18/runloop/)

[http://blog.csdn.net/ztp800201/article/details/9240913](http://blog.csdn.net/ztp800201/article/details/9240913)

<div align=center>
微信公众号 得到最快最新的推送
</div>

<div align=center>
![](http://ww1.sinaimg.cn/large/0060lm7Tgw1f9656jhucpj307607674r.jpg)
</div>
