layout: gcd详细介绍(一)
title: iOS GCD详细介绍
date: 2016-04-10 18:04:00
tags: GCD
categoris: GCD
---
这是一篇GCD基础教程, 对就需要这样说, GCD的强大, 纸上谈兵好像并不能显示它的强大(囧~)
<!-- more -->
今天分享的是关于GCD的知识, 对于GCD的说明: 开发者要做的只是定义想要执行的任务并追加到适当的Dispatch Queue中.存在两种`Dispatch Queue`:`Serial Dispatch Queue`等待现在执行中处理结束`Concurrent Dispatch Queue`不等待现在执行中处理结束, 而`Serial Dispatch Queue`使用一个线程 `Concurrent Dispatch Queue` 使用多个线程

## dispatch_queue_create
```objectivec
/**
第一个参数指定, 线程的名称: 可以给NULL 该名称会出现在应用程序崩溃时所生成的CrashLog中, 所以最好给上名称
第二个参数指定, NULL(Serial Dispatch Queue), 或者 Concurrent Dispatch Queue.
*/
// dispatch_queue_t 代表线程类型  
dispatch_queue_t queue = dispatch_queue_create("my.gcd.example", NULL);
```

`Main Dispatch Queue / Global Dispatch Queue`

Main Dispatch Queue 像他的名字含有Main一样, 是在主线程中执行的Dispatch Queue因为主线程只有一个, 所以他是Serial Dispatch Queue

Global Dispatch Queue 是所有是所有应用程序都能使用的Concurrent Dispatch Queue. 
Global Dispatch Queue 有四个优先级别: High, Default, Low, Background(后台)

各种Dispatch Queue 获取方法如下

```objectivec
// main
dispatch_queue_t mainQueue = dispatch_get_main_queue();
// global
// DISPATCH_QUEUE_PRIORITY_HIGH
// DISPATCH_QUEUE_PRIORITY_DEFAULT
// DISPATCH_QUEUE_PRIORITY_LOW
// DISPATCH_QUEUE_PRIORITY_BACKGROUND
dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)
```
## dispatch_after
经常会有这样的情况, 想在3秒之后执行处理 可能不限于3秒,  使用dispatch_after

```objectivec
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
// do you something
});
```
## Dispatch Group
在追加到Dispatch Queue中的多个处理全部结束后想执行结束处理, 这种应该如何处理呢?? 使用 group 
假设你想, 追加3个Block 到Global Dispatch Queue 这些Block全部执行完, 执行 Main Dispatch 中结束处理用的Block
```objectivec
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, queue, ^{
//
NSLog(@"-------------1");
});
dispatch_group_async(group, queue, ^{
//
NSLog(@"-------------2");
});
dispatch_group_async(group, queue, ^{
//
NSLog(@"-------------3");
});

dispatch_group_notify(group, dispatch_get_main_queue(), ^{
NSLog(@"-------------4");
});
// 2016-05-08 02:02:56.376 GCD-01[3223:59296] -------------1
// 2016-05-08 02:02:56.376 GCD-01[3223:59298] -------------3
// 2016-05-08 02:02:56.376 GCD-01[3223:59297] -------------2
// 2016-05-08 02:02:56.385 GCD-01[3223:59213] -------------4
```
因为多个线程并行执行 所以追加的处理执行的顺序是不确定的, 但是4 一定是最后执行.
无论向什么样的 Dispatch Queue 中追加处理, 使用Dispatch Group 都可以监视这些处理的结束, 一旦所有的都结束执行, 就可以加结束的处理追加到Dispatch Queue, 这就是Gourp的奥义.
## dispatch_group_wait
```objectivec
dispatch_group_wait(group, DISPATCH_TIME_FOREVER); // 永久等待
// 具体使用代码如下
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, queue, ^{
//
NSLog(@"-------------1");
});
dispatch_group_async(group, queue, ^{
//
for (int i = 0; i < 2000; i ++) {
NSLog(@"%d", i);
}

NSLog(@"-------------2");
});
dispatch_group_async(group, queue, ^{
//
NSLog(@"-------------3");
});

dispatch_time_t time1 = dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);

long result = dispatch_group_wait(group, time1);

if (result == 0) {
NSLog(@"全部处理结束");
}else{
NSLog(@"还在处理中");
}
// 2016-05-08 02:19:16.102 GCD-01[3376:65810] 1222
// 2016-05-08 02:19:16.102 GCD-01[3376:65742] 还在处理中
// 2016-05-08 02:19:16.103 GCD-01[3376:65810] 1223
```
## dispatch_barrier_async
下面通过代码对他进行解释
```objectivec
dispatch_queue_t queue = dispatch_queue_create("queue.example", DISPATCH_QUEUE_CONCURRENT);

dispatch_async(queue, ^{
NSLog(@"-------------------1");
});

dispatch_async(queue, ^{
NSLog(@"-------------------2");
});

dispatch_async(queue, ^{
NSLog(@"-------------------3");
});

dispatch_async(queue, ^{
NSLog(@"-------------------4");
});


//   dispatch_barrier_async(queue, ^{
//     NSLog(@"I am a barrier");
//    });


dispatch_async(queue, ^{
NSLog(@"-------------------5");
});

dispatch_async(queue, ^{
NSLog(@"-------------------6");
});

dispatch_async(queue, ^{
NSLog(@"-------------------7");
});

dispatch_async(queue, ^{
NSLog(@"-------------------8");
});

```
在开发的过程中某些功能实现的时候, 我们可能需要一些特定的表现形式, 比如我想让 在 1234 都执行结束之后, 在执行之后的操作(5678), 这样使用 `dispatch_barrier_async` 就可以实现了
## dispatch_sync
dispatch_sync函数 "async" 异步即非同步, sync即是同步.

假设一种场景: 在执行Main Dispatch Queue 时, 使用另外一种线程 Global Dispatch Queue 进行处理, 处理结束后立即使用所得到的结果 代码示例如下
```objectivec
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

dispatch_sync(queue, ^{
//
});
```
sync 容易造成死锁情况. 下面列举几个
情景1
```objectivec
dispatch_queue_t queue2 = dispatch_get_main_queue();
dispatch_sync(queue2, ^{
//
NSLog(@"----------"); // 不会被执行
});
```
情景2
```objectivec
dispatch_queue_t queue3 = dispatch_get_main_queue();
dispatch_async(queue3, ^{
//
dispatch_sync(queue3, ^{
NSLog(@"----------");
});
});
```
情景3
```objectivec
dispatch_queue_t queue4 = dispatch_queue_create("queue.example", DISPATCH_QUEUE_SERIAL);
dispatch_async(queue4, ^{
//
dispatch_sync(queue4, ^{
//
NSLog(@"---------");
});
});
```
## dispatch_apply
dispatch_apply 是 dispatch_sync 和 Dispatch Group 的关联API. 
重复执行Block中代码. 示例如下
```objectivec
dispatch_queue_t queue5 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(5, queue5, ^(size_t i) {
NSLog(@"i= %zu", i);
});
```
## `Dispatch_apply`函数与`Dispatch_sync`函数相同, 都是会等待处理执行结束所以推荐这样使用示例代码如下
```objectivec
dispatch_queue_t queue6 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

// 在Global Dispatch Queue 中非同步执行
dispatch_async(queue6, ^{
// Global Dispatch Queue 等待 Dispatch_apply 函数中的全部处理执行结束
dispatch_apply(5, queue6, ^(size_t index) {
//
NSLog(@"i = %zu", index);
});

// 在Dispatch_apply 函数中的处理全部执行结束
// 在Main Dispatch Queue 中非同步执行

dispatch_async(dispatch_get_main_queue(), ^{
// 用户界面更新等
NSLog(@" end ");
});
});
```
## dispatch_suspend / dispatch_resume
当使用Dispatch Queue 进行复杂处理的时候,有的时候希望不执行已追加的处理. 这种情况下可以挂起Dispatch Queue就可以, 当需要他执行的时候在执行恢复
```objectivec
// 挂起(可以理解为暂停)
dispatch_suspend(queue);
// 恢复
dispatch_resume(queue);
```
###dispatch_once
函数是在应用程序执行中只执行一次指定处理的API
singleton 常用这个函数创建
```objectivec
static dispatch_once_t onceToken;
dispatch_once(&onceToken, ^{
//
// 初始化
});
```
singleton
```objectivec
+ (instancetype)shareVC
{
// 定义了一个标识(onceToken)
// 确保block里的内容只执行一次
static ZJW_VC *vc = nil;
static dispatch_once_t onceToken;
dispatch_once(&onceToken, ^{
vc = [[ZJW_VC alloc] init];
});
return vc;
}
```
##GCD的实现
我们所使用的GCD的API 全部是C语言函数实现, Dispatch Queue通过结构体和链表被实现为FIFO队列
什么是FIFO队列: First Input First Output的缩写，先入先出队列，这是一种传统的按序执行方法，先进入的指令先完成并引退，跟着才执行第二条指令。

## 使用范例
```objectivec
UIImageView *imageView = [[UIImageView alloc] init];
imageView.frame = CGRectMake(20, 20, self.view.frame.size.width - 40, self.view.frame.size.height - 40);
[self.view addSubview:imageView];    
// 使用GCD 下载图片 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,0), ^{
NSString *url =@"http://images11.app.happyjuzi.com/news/201604/22/5719667646455.jpg";
// 从网络获取数据
NSData *data  = [[NSData alloc] initWithContentsOfURL:[NSURL URLWithString:url]];
// 将网络的数据初始化UIImage 对象
UIImage *image = [[UIImage alloc] initWithData:data];
if (image != nil) {
// 该代码块将会有主线程完成
dispatch_async(dispatch_get_main_queue(), ^{
imageView.image = image;
}); // 使用异步更新界面的UI控件
}else{
NSLog(@"错误");
}
});
```

<div align=center>
微信公众号 得到最快最新的推送
</div>

<div align=center>
![](http://ww1.sinaimg.cn/large/0060lm7Tgw1f9656jhucpj307607674r.jpg)
</div>
